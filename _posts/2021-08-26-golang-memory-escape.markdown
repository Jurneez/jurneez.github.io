---
layout: post
title: Golang学习笔记之内存逃逸
tags: [golang, memory excape]
image: '/images/posts/2.jpg'
---

什么是内存逃逸呢？

在程序中，每个函数块都会有自己的内存区域用来存自己的局部变量（内存占用少）、返回地址、返回值之类的数据，这一块内存区域有特定的结构和寻址方式，寻址起来十分迅速，开销很少。这一块内存地址称为栈。栈是线程级别的，大小在创建的时候已经确定，当变量太大的时候，会"逃逸"到堆上，这种现象称为内存逃逸。简单来说，局部变量通过堆分配和回收，就叫内存逃逸。


内存逃逸的危害

堆是一块没有特定结构，也没有固定大小的内存区域，可以根据需要进行调整。全局变量，内存占用较大的局部变量，函数调用结束后不能立刻回收的局部变量都会存在堆里面。变量在堆上的分配和回收都比在栈上开销大的多。对于 go 这种带 GC 的语言来说，会增加 gc 压力，同时也容易造成内存碎片。

---

如何分析内存逃逸

build时添加-gcflags=-m 选项可分析内存逃逸情况,比如输出./main.go:3:6: moved to heap: x 表示局部变量x逃逸到了堆上。

什么情况下经常发生内存逃逸

1. 向 channel 发送指针数据。因为在编译时，不知道channel中的数据会被哪个 goroutine 接收，因此编译器没法知道变量什么时候才会被释放，因此只能放入堆中。
2. 局部变量在函数调用结束后还被其他地方使用，比如函数返回局部变量指针或闭包中引用包外的值。因为变量的生命周期可能会超过函数周期，因此只能放入堆中。
3. 在 slice 或 map 中存储指针。比如 []*string，其后面的数组可能是在栈上分配的，但其引用的值还是在堆上。
4. 切片扩容后长度太大，导致栈空间不足，逃逸到堆上。
5. 在 interface 类型上调用方法。 在 interface 类型上调用方法时会把interface变量使用堆分配， 因为方法的真正实现只能在运行时知道。

---

如何避免内存逃逸呢

1. 对于小型的数据，使用传值而不是传指针，避免内存逃逸。
2. 避免使用长度不固定的slice切片，在编译期无法确定切片长度，只能将切片使用堆分配。
3. interface调用方法会发生内存逃逸，在热点代码片段，谨慎使用。

---
> 参考连接

1. https://segmentfault.com/a/1190000039843497
2. https://www.huaweicloud.com/articles/161e05228469a6a3da5eb313137ddd7f.html